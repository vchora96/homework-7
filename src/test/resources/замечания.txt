
1. А почему у тебя пакеты pages и utils хранятся в пакете tests? Они же не являются тестами и следовательно их необходимо хранить в пакете src.

Ответ: В уроке 26 Page Object у Анатолия была именно такая структура. Как мне казалось,
в пакете src находится исходный код, относящийся к основной логике работы приложения /сервиса, в данном же случае пакеты pages и
utils находятся в пакете test, так как необходимы для правильной работы автотестов.

2. Класс базовой страницы необходимо хранить в пакете страниц, так как этот класс не является утилитами.

Ответ: BasePages и так находится в пакете pages.

3. А почему у тебя класс базовой страницы не абстрактный? В текущей реализации получается мы можем создать класс просто
 страницы, но на самом деле у нас просто страницы не существует. У нас есть определенная страница, а не базовая (тут
  аналогия с животными, мы не можем создать объект просто животного).

Ответ: Исправлено

4. Вот этот локатор надо переписать:

@FindBy(xpath = "//div[@class ='modal__close ic-close js-close-modal']")

Так как у тебя значения в атрибуте класса могут поменяться местами и если это произойдет, то твой элемент найден
не будет и тест упадет. Поэтому необходимо использовать различные функции в xpath такие как contains например, либо
пересмотреть этот локатор.

Ответ: Исправлено

5. У тебя везде используется xpath, но его лучше всего использовать только в том случае, где без него никуда. Лучше
всего использовать css selector, потому что css selector это прямая ссылка на элемент в DOM страницы, а xpath это
 рекурсивный обход дерева страницы и следовательно xpath медленее чем css selectors.

Ответ: Исправил, где смог на css по замечаниям ниже (в остальных случаях оставил xpath)

6. Вот этот локатор тоже надо переписать:

@FindBy(xpath = "//div[@class ='lk-cv-block__select-options lk-cv-block__select-options_left " +
"js-custom-select-options-container']/descendant::button[@title='Viber']")

Ответ: НЕ УДАЛОСЬ найти с помощью CSS однозначно: button[title='Viber'] находит 4 элемента

7. И вот этот:

@FindBy(xpath = "//div[@class ='lk-cv-block__select-options lk-cv-block__select-options_left " +
"js-custom-select-options-container']/descendant::button[@title ='Skype']")

Ответ: НЕ УДАЛОСЬ найти с помощью CSS однозначно: button[title='Skype'] находит 4 элемента

8. И вот этот:

@FindBy(xpath = "//input[@class='input input_straight-top-left " + "input_straight-bottom-left lk-cv-block__input " +
" lk-cv-block__input_9 lk-cv-block__input_md-8']")

Ответ: Исправлено

9. Вот этот локатор надо переписать:

@FindBy(xpath = "//div[@class = 'header2-menu__item-wrapper header2-menu__item-wrapper__username']")

Ответ: Исправлено

10. Вот тут у тебя открывается страница:

String link = "https://otus.ru";
driver.get(link);

А если мы захотим прогнать тесты на тестовом стейдже с другим хостнеймом? Получается нам прийдется менять руками прямо
в коде этот хостнейм. Лучше всего получать хостнейм на страницу из контекста выполнения тестов: System.getProperty("base.url");

Ответ: Исправлено

11. Вот у тебя есть вводы логина и пароля, но я бы еще добавил проверку, что пароль введен в поле ввода, как и логин:

mail.sendKeys(login);
logger.info("Ввели почту");

password.sendKeys(pass);
logger.info("Ввели пароль");

Ответ: В 26 уроке часть с заполнением данных и часть с проверкой
 успешности заполнения была разнесена на 2 этапа, ориентировался на это

12. И еще не нужно сильно так перегружать методы. Например у тебя есть высокоуровневый метод авторизации:

logInByUser()

Но лучше всего в таком методе делать вызовы более низкоуовневых методов. Например:

- Делаешь метод ввода логина
- Отдельный метод проверки, что логин введен в поле ввода
- Делаешь метод ввода пароля
- Отдельный метод проверки, что пароль введен

Такие методы позволят тебе строить универсальные комбинации в сценариях, например если ввести логин не соответствующий
какому-либо шаблону, то кнопка войти может быть отключена и это например надо проверить.

А высокоуровневый метод авторизации будет следующий:

logInByUser() {
this.setLogin("test")
.checkLogin("test")
.setPassword("123456")
.checkPassword("123456")
}

Что-то типа такого надо сделать в общем.

Ответ: Исправлено

13. Этот локатор надо переписать:
@FindBy(xpath = "//div[@class ='input input_full lk-cv-block__input lk-cv-block__input_fake " +
"lk-cv-block__input_select-fake js-custom-select-presentation']")

Ответ: Исправлено

14. Смотри у тебя есть локаторы на страну и город:

@FindBy(xpath = "//button[@title='Узбекистан']")
private WebElement uzbekistan;

@FindBy(xpath = "//button[@title='Бухара']")
private WebElement buhara;

И они завязаны на определенную страну и определенный город. А что, если нам в тестах нужно будет выбрать другой город в
другой стране? Получается мы сделать это не сможем. Лучше всего сделать метод, который будет принимать enum города и его
 выбирать. А страну (отдельный enum стран) связать с городом в enum. Получается у нас будет универсальный локатор и
 универсальный метод для выбора любого города и страны. А так харкодить не нужно.

 Ответ: Исправлено

15. Аналогичное замечание и к выбору уровня владения языком. Уровень языка не нужно харкодить в локаторе и его нужно
передавать как константу из enum

Ответ: Исправлено

16. Открывать страничку необходимо через метод open(), который необходимо написать в классе базовой страницы и
 вызывать на объектах наследниках от базовой страницы. Потому что метод открытия страницы open() является общим методом
  для всех страниц.

Ответ: Исправлено

17. А что это за класс с локаторами:

TestLocatorsData

Не нужно локаторы хранить в отдельном классе. Необходимо эти локаторы раскидать по соответствующим классам компонентам или
 страницам и инкапсулировать. А открыть только методы взаимодействия с этими элементами на странице. применяем шаблон
 проектирования PageObject, который нам говорит, что нам необходимо скрыть элементы страницы или компонента и открыть
  интерфейс взаимодействия с этими элементами. В общем этот класс необходимо из проекта удалить.

Ответ: Исправлено

18. Вот в этом классе CheckHelper у тебя различные методы проверок, но так тоже делать плохая практика, потому что у тебя
будут появляться различные комбинации проверок на различных страницах и этот класс будет увеличиваться и потом дойдет до того,
что его поддерживать станет сильно дорого. Поэтому такие проверки необходимо раскидать по методам классов страниц или
компонентов и вызывать в тесте. Предлагаю этот класс убрать.

Ответ: Здесь тоже у меня вопрос. В уроке 26 было сказано, что в классах страниц и компонентов не должно быть никаких проверок.
Я неправильно понял этот момент?

19. А для чего тебе в фабрике два метода create? Обычно никто не использует драйвер без опций и аргументом и поэтому один
create можно удалить6 но если тебе хочется создавать сессию браузера с опциями по умолчанию, то передавай в create объект
new ChromeOptions() например.

Ответ: Исправлено

20. Вот тут ты закрываешь не только браузер, но и сессию драйвера:

driver.quit();
driver = WebDriverFactory.create(type);

А для чего? Заново создавать сессию селениум драйвера это очень дорогая операция. по ресурсам. Лучше всего просто закрыть
сессию браузера через метод close и заново открыть страничку:

MainPage mainPage = new MainPage(driver);
mainPage.open();

driver.close();

mainPage.open();

В этом примере мы открываем страничку главной страницы, потом закрываем окно браузера и заново его создаем и открываем
 страничку главной страницы. Так намного тратится меньше ресурсов и все равно будет открыт чистый браузер.

Ответ: Исправлено